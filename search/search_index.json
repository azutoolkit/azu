{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction AZU is a TOOLKIT for artisans with expressive, elegant and simple design that offers great performance to build rich, interactive and type safe applications quickly, with less code and conhesive parts that adapts to your prefer style. Benefits Plain Crystal, little to no DSL Super easy to learn and adopt Type safe everywhere Adopts your choice of architectural pattern: Modular Pipes and Filters Event Driven Layered Tools Azu AZU Toolkit for artisans with expressive, elegant syntax that offers great performance to build rich, interactive type safe, applications quickly, with less code and conhesive parts that adapts to your prefer style. Learn more about Azu Flux Flux makes it easy to Test web applications by simulating a Real User would interact with your web based app. Learn more about Flux Echo Echo is a messaging framework built in Crystal Language, that applies the Pub/Sub pattern with asynchronous messaging service. Echo provides instant event notifications for distributed applications, especially those that are decoupled into smaller, independent building blocks. Learn more about Echo Schema Schemas come to solve a simple problem. Sometimes we would like to have type-safe guarantee parameters when parsing HTTP requests or Hash(String, String) for a request. Schema shard resolve precisely this problem with the added benefit of enabling self validating schemas that can be applied to any object, requiring little to no boilerplate code making you more productive from the moment you use this shard. Learn more about Schema JoobQ JoobQ is a fast, efficient asynchronous reliable job queue scheduler library processing. Jobs are submitted to a job queue, where they reside until they are able to be scheduled to run in a compute environment. Learn more about JoobQ","title":"Introduction"},{"location":"#introduction","text":"AZU is a TOOLKIT for artisans with expressive, elegant and simple design that offers great performance to build rich, interactive and type safe applications quickly, with less code and conhesive parts that adapts to your prefer style.","title":"Introduction"},{"location":"#benefits","text":"Plain Crystal, little to no DSL Super easy to learn and adopt Type safe everywhere Adopts your choice of architectural pattern: Modular Pipes and Filters Event Driven Layered","title":"Benefits"},{"location":"#tools","text":"","title":"Tools"},{"location":"#azu","text":"AZU Toolkit for artisans with expressive, elegant syntax that offers great performance to build rich, interactive type safe, applications quickly, with less code and conhesive parts that adapts to your prefer style. Learn more about Azu","title":"Azu"},{"location":"#flux","text":"Flux makes it easy to Test web applications by simulating a Real User would interact with your web based app. Learn more about Flux","title":"Flux"},{"location":"#echo","text":"Echo is a messaging framework built in Crystal Language, that applies the Pub/Sub pattern with asynchronous messaging service. Echo provides instant event notifications for distributed applications, especially those that are decoupled into smaller, independent building blocks. Learn more about Echo","title":"Echo"},{"location":"#schema","text":"Schemas come to solve a simple problem. Sometimes we would like to have type-safe guarantee parameters when parsing HTTP requests or Hash(String, String) for a request. Schema shard resolve precisely this problem with the added benefit of enabling self validating schemas that can be applied to any object, requiring little to no boilerplate code making you more productive from the moment you use this shard. Learn more about Schema","title":"Schema"},{"location":"#joobq","text":"JoobQ is a fast, efficient asynchronous reliable job queue scheduler library processing. Jobs are submitted to a job queue, where they reside until they are able to be scheduled to run in a compute environment. Learn more about JoobQ","title":"JoobQ"},{"location":"authly/","text":"Authly OAuth2 Provider Server Library for the Crystal Language Authly is an OAuth2 Library for creating Authorization Servers that supports OAuth2 authorization mechanisms. The OAuth 2.0 specification is a flexibile authorization framework that describes a number of grants (\u201cmethods\u201d) for a client application to acquire an access token (which represents a user\u2019s permission for the client to access their data) which can be used to authenticate a request to an API endpoint. The specification describes five grants for acquiring an access token: Authorization code grant Implicit grant Resource owner credentials grant Client credentials grant Refresh token grant Authorization Use Cases The first step of OAuth 2 is to get authorization from the user. For browser-based or mobile apps, this is usually accomplished by displaying an interface provided by the service to the user. OAuth 2 provides several \"grant types\" for different use cases. The grant types defined are: Authorization code grant for apps running on a web server, browser-based and mobile apps Resource owner credentials grant for logging in with a username and password (only for first-party apps) Client credentials grant for application access without a user present, think microservices Implicit grant was previously recommended for clients without a secret, but has been superseded by using the Authorization Code grant with PKCE Terminology Resource owner (the user) Entity that can grant access to a protected resource. Typically, this is the end-user. Resource server (the API) Server hosting the protected resources. This is the API you want to access. Authorization server (can be the same server as the API) Server that authenticates the Resource Owner and issues Access Tokens after getting proper authorization. In this case, Auth0. Client (the third-party app) Application requesting access to a protected resource on behalf of the Resource Owner. User Agent Agent used by the Resource Owner to interact with the Client (for example, a browser or a native application). Note This implementation uses JWT tokens for storage by default. Installation Add the dependency to your shard.yml : dependencies : authly : github : azutoolkit/authly Run shards install Usage require \"authly\" Configuration # In memory storage of clients (3rd Party Apps) Authly . clients << Authly :: Client . new ( \"example\" , \"secret\" , \"https://www.example.com/callback\" , \"1\" ) # Authly . owners << Authly :: Owner . new ( \"username\" , \"password\" ) # Or use your own classes and implement interface # Clients class AppService include AuthorizableClient end # Owners class UserService include AuthorizableOwner end # Configure Authly . configure do | c | # Secret Key for JWT Tokens c . secret_key = \"Some Secret\" # Refresh Token Time To Live c . refresh_ttl = 1 . hour # Authorization Code Time To Live c . code_ttl = 1 . hour # Access Token Time To Live c . access_ttl = 1 . hour # Using your own classes c . owners = UserService . new c . clients = AppService . new end Perform Authorizations Authly . authorize ( * all_args ) # Or do it yourself Authly :: ClientCredentials . new ( client_id , client_secret , scope ) . authorize! Authly :: AuthorizationCode . new ( client_id , client_secret , redirect_uri , code , scope , state ) . authorize! Authly :: Password . new ( client_id , client_secret , username , password , scope ) . authorize! Authly :: RefreshToken . new ( client_id , client_secret , refresh_token , scope ) . authorize! Authly :: Implicit . new ( client_id , redirect_uri , scope , state ) . authorize! Exceptions Authly returns exceptions according to the OAuth2 protocol of type Error with code , type and message properties. Error Type and Messages invalid_redirect_uri : \"Invalid redirect uri\" , invalid_state : \"Invalid state\" , invalid_scope : \"Invalid scope value in the request\" , invalid_client : \"Client authentication failed, such as if the request contains an invalid client ID or secret.\" , owner_credentials : \"Invalid owner credentials\" , invalid_request : \"The request is missing a parameter so the server can\u2019t proceed with the request\" , invalid_grant : \"The authorization code is invalid or expired.\" , unauthorized_client : \"This client is not authorized to use the requested grant type\" , unsupported_grant_type : \"Invalid or unknown grant type\" , access_denied : \"The user or authorization server denied the request\" , Contributing Fork it ( https://github.com/azutoolkit/authly/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request Contributors Elias Perez - Initial work","title":"Authly"},{"location":"authly/#authly","text":"","title":"Authly"},{"location":"authly/#oauth2-provider-server-library-for-the-crystal-language","text":"Authly is an OAuth2 Library for creating Authorization Servers that supports OAuth2 authorization mechanisms. The OAuth 2.0 specification is a flexibile authorization framework that describes a number of grants (\u201cmethods\u201d) for a client application to acquire an access token (which represents a user\u2019s permission for the client to access their data) which can be used to authenticate a request to an API endpoint. The specification describes five grants for acquiring an access token: Authorization code grant Implicit grant Resource owner credentials grant Client credentials grant Refresh token grant","title":"OAuth2 Provider Server Library for the Crystal Language"},{"location":"authly/#authorization-use-cases","text":"The first step of OAuth 2 is to get authorization from the user. For browser-based or mobile apps, this is usually accomplished by displaying an interface provided by the service to the user. OAuth 2 provides several \"grant types\" for different use cases. The grant types defined are: Authorization code grant for apps running on a web server, browser-based and mobile apps Resource owner credentials grant for logging in with a username and password (only for first-party apps) Client credentials grant for application access without a user present, think microservices Implicit grant was previously recommended for clients without a secret, but has been superseded by using the Authorization Code grant with PKCE","title":"Authorization Use Cases"},{"location":"authly/#terminology","text":"Resource owner (the user) Entity that can grant access to a protected resource. Typically, this is the end-user. Resource server (the API) Server hosting the protected resources. This is the API you want to access. Authorization server (can be the same server as the API) Server that authenticates the Resource Owner and issues Access Tokens after getting proper authorization. In this case, Auth0. Client (the third-party app) Application requesting access to a protected resource on behalf of the Resource Owner. User Agent Agent used by the Resource Owner to interact with the Client (for example, a browser or a native application). Note This implementation uses JWT tokens for storage by default.","title":"Terminology"},{"location":"authly/#installation","text":"Add the dependency to your shard.yml : dependencies : authly : github : azutoolkit/authly Run shards install","title":"Installation"},{"location":"authly/#usage","text":"require \"authly\"","title":"Usage"},{"location":"authly/#configuration","text":"# In memory storage of clients (3rd Party Apps) Authly . clients << Authly :: Client . new ( \"example\" , \"secret\" , \"https://www.example.com/callback\" , \"1\" ) # Authly . owners << Authly :: Owner . new ( \"username\" , \"password\" ) # Or use your own classes and implement interface # Clients class AppService include AuthorizableClient end # Owners class UserService include AuthorizableOwner end # Configure Authly . configure do | c | # Secret Key for JWT Tokens c . secret_key = \"Some Secret\" # Refresh Token Time To Live c . refresh_ttl = 1 . hour # Authorization Code Time To Live c . code_ttl = 1 . hour # Access Token Time To Live c . access_ttl = 1 . hour # Using your own classes c . owners = UserService . new c . clients = AppService . new end Perform Authorizations Authly . authorize ( * all_args ) # Or do it yourself Authly :: ClientCredentials . new ( client_id , client_secret , scope ) . authorize! Authly :: AuthorizationCode . new ( client_id , client_secret , redirect_uri , code , scope , state ) . authorize! Authly :: Password . new ( client_id , client_secret , username , password , scope ) . authorize! Authly :: RefreshToken . new ( client_id , client_secret , refresh_token , scope ) . authorize! Authly :: Implicit . new ( client_id , redirect_uri , scope , state ) . authorize!","title":"Configuration"},{"location":"authly/#exceptions","text":"Authly returns exceptions according to the OAuth2 protocol of type Error with code , type and message properties.","title":"Exceptions"},{"location":"authly/#error-type-and-messages","text":"invalid_redirect_uri : \"Invalid redirect uri\" , invalid_state : \"Invalid state\" , invalid_scope : \"Invalid scope value in the request\" , invalid_client : \"Client authentication failed, such as if the request contains an invalid client ID or secret.\" , owner_credentials : \"Invalid owner credentials\" , invalid_request : \"The request is missing a parameter so the server can\u2019t proceed with the request\" , invalid_grant : \"The authorization code is invalid or expired.\" , unauthorized_client : \"This client is not authorized to use the requested grant type\" , unsupported_grant_type : \"Invalid or unknown grant type\" , access_denied : \"The user or authorization server denied the request\" ,","title":"Error Type and Messages"},{"location":"authly/#contributing","text":"Fork it ( https://github.com/azutoolkit/authly/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request","title":"Contributing"},{"location":"authly/#contributors","text":"Elias Perez - Initial work","title":"Contributors"},{"location":"echo/","text":"ECHO Pub/Sub Framework Echo is a messaging framework built in Crystal Language, that applies the Pub/Sub pattern with asynchronous messaging service. Echo provides instant event notifications for distributed applications, especially those that are decoupled into smaller, independent building blocks. Communication Model Echo uses Topic based messaging, where messages are published to named topics invoked as Stream(M) type objects. The Producer(Messate, Stream) is the one who creates these Streams . Consumer subscribe to those topics to receive messages from whereever they appear. Types of Streams Echo has 3 types of Stream built-in these are: Redis Streams - Uses Redis Stream data type introduced in Redis 5.0 which models a log data structure in a more abstract way. Websockets Streams - Uses WebSockets to provide a long-lived connection to deliver messages from producer to consumers In-Memory Streams - Uses Crystal Channels to deliver messages from Producer to Consumers internally within an application Core concepts Stream A named resource to which messages are sent by publishers. Producer A named resource representing the stream of events (messages) from a single, specific topic, to be delivered to the subscribing application (consumers). Consumer A named resource representing the application/entity subscribed to a stream to receive events. Message The combination of data and (optional) attributes that a producer sends to a Stream(Message) and is eventually delivered to consumers. Producer Consumer Relationship A producer application creates and sends events to a stream. Consumer applications create a subscription to a event to receive messages from it. Communication can be one-to-many (fan-out), many-to-one (fan-in), and many-to-many. Common use cases Balancing workloads in network clusters. For example, a large queue of tasks can be efficiently distributed among multiple workers. Implementing asynchronous workflows. For example, an order processing application can place an order on a stream, from which it can be processed by one or more workers. Distributing event notifications. For example, a service that accepts user signups can send notifications whenever a new user registers, and downstream services can subscribe to receive notifications of the event. Refreshing distributed caches. For example, an application can publish invalidation events to update the IDs of objects that have changed. Logging to multiple systems. For example, an application can write logs to the monitoring system, to a database for later querying, and so on. Data streaming from various processes or devices. For example, a residential sensor can stream data to backend servers hosted in the cloud. Reliability improvement. For example, a single-zone Compute service can operate in additional zones by subscribing to a common topic, to recover from failures in a zone or region. Installation Add the dependency to your shard.yml : dependencies : echo : github : azutoolkit/echo Run shards install Example Usage Echo::Redis is replaceable with Echo::Memory and Echo::WebSocket require \"echo\" struct World include Echo :: Message getter name : String = \"\" def initialize ( @name ) end end struct Marco include Echo :: Message getter name = \"Marco\" end class WorldProducer include Echo :: Producer ( World , Echo :: Redis ) include Echo :: Producer ( Marco , Echo :: Redis ) # subscribe and publish methods are now available end class WorldConsumer include Echo :: Consumer ( World , Echo :: Redis ) include Echo :: Consumer ( Marco , Echo :: Redis ) getter count : Int32 = 0 def on ( event : World | Marco ) @count += 1 ... do something ... end end Contributing Fork it ( https://github.com/azutoolkit/echo/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request Contributors Elias J. Perez - creator and maintainer","title":"ECHO"},{"location":"echo/#echo","text":"","title":"ECHO"},{"location":"echo/#pubsub-framework","text":"Echo is a messaging framework built in Crystal Language, that applies the Pub/Sub pattern with asynchronous messaging service. Echo provides instant event notifications for distributed applications, especially those that are decoupled into smaller, independent building blocks.","title":"Pub/Sub Framework"},{"location":"echo/#communication-model","text":"Echo uses Topic based messaging, where messages are published to named topics invoked as Stream(M) type objects. The Producer(Messate, Stream) is the one who creates these Streams . Consumer subscribe to those topics to receive messages from whereever they appear.","title":"Communication Model"},{"location":"echo/#types-of-streams","text":"Echo has 3 types of Stream built-in these are: Redis Streams - Uses Redis Stream data type introduced in Redis 5.0 which models a log data structure in a more abstract way. Websockets Streams - Uses WebSockets to provide a long-lived connection to deliver messages from producer to consumers In-Memory Streams - Uses Crystal Channels to deliver messages from Producer to Consumers internally within an application","title":"Types of Streams"},{"location":"echo/#core-concepts","text":"Stream A named resource to which messages are sent by publishers. Producer A named resource representing the stream of events (messages) from a single, specific topic, to be delivered to the subscribing application (consumers). Consumer A named resource representing the application/entity subscribed to a stream to receive events. Message The combination of data and (optional) attributes that a producer sends to a Stream(Message) and is eventually delivered to consumers.","title":"Core concepts"},{"location":"echo/#producer-consumer-relationship","text":"A producer application creates and sends events to a stream. Consumer applications create a subscription to a event to receive messages from it. Communication can be one-to-many (fan-out), many-to-one (fan-in), and many-to-many.","title":"Producer Consumer Relationship"},{"location":"echo/#common-use-cases","text":"Balancing workloads in network clusters. For example, a large queue of tasks can be efficiently distributed among multiple workers. Implementing asynchronous workflows. For example, an order processing application can place an order on a stream, from which it can be processed by one or more workers. Distributing event notifications. For example, a service that accepts user signups can send notifications whenever a new user registers, and downstream services can subscribe to receive notifications of the event. Refreshing distributed caches. For example, an application can publish invalidation events to update the IDs of objects that have changed. Logging to multiple systems. For example, an application can write logs to the monitoring system, to a database for later querying, and so on. Data streaming from various processes or devices. For example, a residential sensor can stream data to backend servers hosted in the cloud. Reliability improvement. For example, a single-zone Compute service can operate in additional zones by subscribing to a common topic, to recover from failures in a zone or region.","title":"Common use cases"},{"location":"echo/#installation","text":"Add the dependency to your shard.yml : dependencies : echo : github : azutoolkit/echo Run shards install","title":"Installation"},{"location":"echo/#example-usage","text":"Echo::Redis is replaceable with Echo::Memory and Echo::WebSocket require \"echo\" struct World include Echo :: Message getter name : String = \"\" def initialize ( @name ) end end struct Marco include Echo :: Message getter name = \"Marco\" end class WorldProducer include Echo :: Producer ( World , Echo :: Redis ) include Echo :: Producer ( Marco , Echo :: Redis ) # subscribe and publish methods are now available end class WorldConsumer include Echo :: Consumer ( World , Echo :: Redis ) include Echo :: Consumer ( Marco , Echo :: Redis ) getter count : Int32 = 0 def on ( event : World | Marco ) @count += 1 ... do something ... end end","title":"Example Usage"},{"location":"echo/#contributing","text":"Fork it ( https://github.com/azutoolkit/echo/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request","title":"Contributing"},{"location":"echo/#contributors","text":"Elias J. Perez - creator and maintainer","title":"Contributors"},{"location":"flux/","text":"flux Flux makes it easy to Test web applications by simulating a Real User would interact with your web based app. This project uses Marionette Marionette is an automation driver for Mozilla\u2019s Gecko engine. It can remotely control either the UI or the internal JavaScript of a Gecko platform, such as Firefox. It can control both the chrome (i.e. menus and functions) or the content (the webpage loaded inside the browsing context), giving a high level of control and ability to replicate user actions. In addition to performing actions on the browser, Marionette can also read the properties and attributes of the DOM. If this sounds similar to Selenium/WebDriver then you\u2019re correct! Marionette shares much of the same ethos and API as Selenium/WebDriver, with additional commands to interact with Gecko\u2019s chrome interface. Its goal is to replicate what Selenium does for web content: to enable the tester to have the ability to send commands to remotely control a user agent. Read more about Marionetter https://firefox-source-docs.mozilla.org/testing/marionette/Intro.html How does it work Marionette consists of two parts: a server which takes requests and executes them in Gecko, and a client. The client sends commands to the server and the server executes the command inside the browser. When would I use it If you want to perform UI tests with browser chrome or content, Marionette is the tool you\u2019re looking for! You can use it to control either web content, or Firefox itself. Installation Add the dependency to your shard.yml : dependencies : flux : github : azutoolkit/flux Run shards install Usage require \"flux\" require \"./spec_helper\" class UserFlux < Flux def signup step do visit \"http://localhost:4000/register\" fill \"first_name\" , \"John\" fill \"last_name\" , \"Doe\" fill \"email\" , \"john.doe@example.com\" fill \"password\" , \"example\" fill \"password_confirm\" , \"example\" checkbox id : \"terms-checkbox\" , checked : true submit \"submit\" end end end describe \"User Signup\" do user = UserFlux . new it \"User visits site\" do user . signup # ...add assertions... end end Run your tests \u276f crystal spec [ DEBUG ] - Using firefox executable at /usr/ bin / firefox [ DEBUG ] - Launching browser [ DEBUG ] - Initialized a new browser instance [ DEBUG ] - Creating new session with capabilities : { acceptInsecureCerts : false , timeouts : { implicit : 30000 , pageLoad : 30000 , script : 30000 }} *** You are running in headless mode . [ DEBUG ] - Navigating to http : // localhost : 4000 / register [ DEBUG ] - Executing script [ DEBUG ] - Quitting browser [ DEBUG ] - Setting browser context to Chrome [ DEBUG ] - Executing script [ DEBUG ] - Setting browser context to Content . Finished in 1.36 seconds 1 examples , 0 failures , 0 errors , 0 pending Development Help with: Add configurator to customize the driver Define more usable and meaningful helper methods for testing Your ideas welcome, feel free to open an issue or PR Contributing 1. Fork it (<https://github.com/azutoolkit/flux/fork>) 2. Create your feature branch (`git checkout -b my-new-feature`) 3. Commit your changes (`git commit -am 'Add some feature'`) 4. Push to the branch (`git push origin my-new-feature`) 5. Create a new Pull Request Contributors Elias J. Perez - creator and maintainer","title":"flux"},{"location":"flux/#flux","text":"Flux makes it easy to Test web applications by simulating a Real User would interact with your web based app. This project uses Marionette Marionette is an automation driver for Mozilla\u2019s Gecko engine. It can remotely control either the UI or the internal JavaScript of a Gecko platform, such as Firefox. It can control both the chrome (i.e. menus and functions) or the content (the webpage loaded inside the browsing context), giving a high level of control and ability to replicate user actions. In addition to performing actions on the browser, Marionette can also read the properties and attributes of the DOM. If this sounds similar to Selenium/WebDriver then you\u2019re correct! Marionette shares much of the same ethos and API as Selenium/WebDriver, with additional commands to interact with Gecko\u2019s chrome interface. Its goal is to replicate what Selenium does for web content: to enable the tester to have the ability to send commands to remotely control a user agent. Read more about Marionetter https://firefox-source-docs.mozilla.org/testing/marionette/Intro.html","title":"flux"},{"location":"flux/#how-does-it-work","text":"Marionette consists of two parts: a server which takes requests and executes them in Gecko, and a client. The client sends commands to the server and the server executes the command inside the browser.","title":"How does it work"},{"location":"flux/#when-would-i-use-it","text":"If you want to perform UI tests with browser chrome or content, Marionette is the tool you\u2019re looking for! You can use it to control either web content, or Firefox itself.","title":"When would I use it"},{"location":"flux/#installation","text":"Add the dependency to your shard.yml : dependencies : flux : github : azutoolkit/flux Run shards install","title":"Installation"},{"location":"flux/#usage","text":"require \"flux\" require \"./spec_helper\" class UserFlux < Flux def signup step do visit \"http://localhost:4000/register\" fill \"first_name\" , \"John\" fill \"last_name\" , \"Doe\" fill \"email\" , \"john.doe@example.com\" fill \"password\" , \"example\" fill \"password_confirm\" , \"example\" checkbox id : \"terms-checkbox\" , checked : true submit \"submit\" end end end describe \"User Signup\" do user = UserFlux . new it \"User visits site\" do user . signup # ...add assertions... end end Run your tests \u276f crystal spec [ DEBUG ] - Using firefox executable at /usr/ bin / firefox [ DEBUG ] - Launching browser [ DEBUG ] - Initialized a new browser instance [ DEBUG ] - Creating new session with capabilities : { acceptInsecureCerts : false , timeouts : { implicit : 30000 , pageLoad : 30000 , script : 30000 }} *** You are running in headless mode . [ DEBUG ] - Navigating to http : // localhost : 4000 / register [ DEBUG ] - Executing script [ DEBUG ] - Quitting browser [ DEBUG ] - Setting browser context to Chrome [ DEBUG ] - Executing script [ DEBUG ] - Setting browser context to Content . Finished in 1.36 seconds 1 examples , 0 failures , 0 errors , 0 pending","title":"Usage"},{"location":"flux/#development","text":"Help with: Add configurator to customize the driver Define more usable and meaningful helper methods for testing Your ideas welcome, feel free to open an issue or PR","title":"Development"},{"location":"flux/#contributing","text":"1. Fork it (<https://github.com/azutoolkit/flux/fork>) 2. Create your feature branch (`git checkout -b my-new-feature`) 3. Commit your changes (`git commit -am 'Add some feature'`) 4. Push to the branch (`git push origin my-new-feature`) 5. Create a new Pull Request","title":"Contributing"},{"location":"flux/#contributors","text":"Elias J. Perez - creator and maintainer","title":"Contributors"},{"location":"joobq/","text":"JoobQ JoobQ is a fast, efficient asynchronous reliable job queue scheduler library processing. Jobs are submitted to a job queue, where they reside until they are able to be scheduled to run in a compute environment. Features: [x] Priority queues based on number of workers [x] Reliable queue [x] Error Handling [x] Retry Jobs with automatic Delays [x] Cron Like Periodic Jobs [x] Delayed Jobs [x] Stop execution of workers [x] Jobs expiration Help Wanted - [ ] CLI to manage queues and monitor server - [ ] Rest API: Rest api to schedule jobs - [ ] Throttle (Rate limit) - [ ] Approve Queue?: Jobs have to manually approved to execute Installation dependencies : joobq : github : azutoolkit/joobq Then run: shards install Requirements This project uses REDIS with the TimeSeries module loaded. The Redis TimeSeries is used to monitor stats of job execution the module is free for use and easy to configure. Follow the guidelines at redistimeseries.io Loading and Configuring Redis TimeSeries Use DUPLICATE POLICY FIRST to ignore duplicate stats entries redis-server --loadmodule ./redistimeseries.so DUPLICATE_POLICY FIRST Configuration Options require \"joobq\" Environment variables REDIS_HOST = localhost REDIS_PORT = 6379 REDIS_POOL_SIZE = 50 REDIS_TIMEOUT = 0 .2 Defining Queues Defining Queues: Queues are of type Hash(String, Queue(T)) where the name of the key matches the name of the Queue. Properties Name: queue:email Number Workers: 10 module JoobQ QUEUES = { \"queue:email\" => Queue ( EmailJob ) . new ( \"queue:email\" , 10 )} end Jobs To define Jobs, must include the JoobQ::Job module, and must implement perform method struct EmailJob include JoobQ :: Job # Name of the queue to be processed by @queue = \"default\" # Number Of Retries for this job @retries = 0 # Job Expiration @expires = 1 . days . total_seconds . to_i # Initialize as normal with or without named tuple arguments def initialize ( email_address : String ) end def perform # Logic to handle job execution end end Executing Job EmailJob . perform ( email_address : \"john.doe@example.com\" ) EmailJob . perform ( within : 1 . hour , email_address : \"john.doe@example.com\" ) Defining And Scheduling Recurring Jobs module JoobQ scheduler . register do cron \"5 4 * * *\" { Somejob . perform } delay job_instance , for : 1 . minute every 1 . hour , EmailJob , email_address : \"notify@example.com\" end end Running JoobQ Starts JoobQ server and listens for jobs JoobQ . forge Statistics JoobQ includes a Statistics class that allow you get stats about queue performance. Available stats total enqueued jobs total, percent completed jobs total, percent retry jobs total, percent dead jobs total busy jobs total delayed jobs Contributing Fork it ( https://github.com/azutoolkit/joobq/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request Contributors Elias J. Perez - creator and maintainer","title":"JoobQ"},{"location":"joobq/#joobq","text":"JoobQ is a fast, efficient asynchronous reliable job queue scheduler library processing. Jobs are submitted to a job queue, where they reside until they are able to be scheduled to run in a compute environment. Features: [x] Priority queues based on number of workers [x] Reliable queue [x] Error Handling [x] Retry Jobs with automatic Delays [x] Cron Like Periodic Jobs [x] Delayed Jobs [x] Stop execution of workers [x] Jobs expiration Help Wanted - [ ] CLI to manage queues and monitor server - [ ] Rest API: Rest api to schedule jobs - [ ] Throttle (Rate limit) - [ ] Approve Queue?: Jobs have to manually approved to execute","title":"JoobQ"},{"location":"joobq/#installation","text":"dependencies : joobq : github : azutoolkit/joobq Then run: shards install","title":"Installation"},{"location":"joobq/#requirements","text":"This project uses REDIS with the TimeSeries module loaded. The Redis TimeSeries is used to monitor stats of job execution the module is free for use and easy to configure. Follow the guidelines at redistimeseries.io","title":"Requirements"},{"location":"joobq/#loading-and-configuring-redis-timeseries","text":"Use DUPLICATE POLICY FIRST to ignore duplicate stats entries redis-server --loadmodule ./redistimeseries.so DUPLICATE_POLICY FIRST","title":"Loading and Configuring Redis TimeSeries"},{"location":"joobq/#configuration-options","text":"require \"joobq\" Environment variables REDIS_HOST = localhost REDIS_PORT = 6379 REDIS_POOL_SIZE = 50 REDIS_TIMEOUT = 0 .2","title":"Configuration Options"},{"location":"joobq/#defining-queues","text":"Defining Queues: Queues are of type Hash(String, Queue(T)) where the name of the key matches the name of the Queue.","title":"Defining Queues"},{"location":"joobq/#properties","text":"Name: queue:email Number Workers: 10 module JoobQ QUEUES = { \"queue:email\" => Queue ( EmailJob ) . new ( \"queue:email\" , 10 )} end","title":"Properties"},{"location":"joobq/#jobs","text":"To define Jobs, must include the JoobQ::Job module, and must implement perform method struct EmailJob include JoobQ :: Job # Name of the queue to be processed by @queue = \"default\" # Number Of Retries for this job @retries = 0 # Job Expiration @expires = 1 . days . total_seconds . to_i # Initialize as normal with or without named tuple arguments def initialize ( email_address : String ) end def perform # Logic to handle job execution end end Executing Job EmailJob . perform ( email_address : \"john.doe@example.com\" ) EmailJob . perform ( within : 1 . hour , email_address : \"john.doe@example.com\" )","title":"Jobs"},{"location":"joobq/#defining-and-scheduling-recurring-jobs","text":"module JoobQ scheduler . register do cron \"5 4 * * *\" { Somejob . perform } delay job_instance , for : 1 . minute every 1 . hour , EmailJob , email_address : \"notify@example.com\" end end","title":"Defining And Scheduling Recurring Jobs"},{"location":"joobq/#running-joobq","text":"Starts JoobQ server and listens for jobs JoobQ . forge","title":"Running JoobQ"},{"location":"joobq/#statistics","text":"JoobQ includes a Statistics class that allow you get stats about queue performance. Available stats total enqueued jobs total, percent completed jobs total, percent retry jobs total, percent dead jobs total busy jobs total delayed jobs","title":"Statistics"},{"location":"joobq/#contributing","text":"Fork it ( https://github.com/azutoolkit/joobq/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request","title":"Contributing"},{"location":"joobq/#contributors","text":"Elias J. Perez - creator and maintainer","title":"Contributors"},{"location":"schema/","text":"Schema Schemas come to solve a simple problem. Sometimes we would like to have type-safe guarantee parameters when parsing HTTP requests or Hash(String, String) for a request. Schema shard resolve precisely this problem with the added benefit of enabling self validating schemas that can be applied to any object, requiring little to no boilerplate code making you more productive from the moment you use this shard. Self validating Schemas are beneficial, and in my opinion, ideal, for when defining API Requests, Web Forms, JSON. Schema-Validation Takes a different approach and focuses a lot on explicitness, clarity, and precision of validation logic. It is designed to work with any data input, whether it\u2019s a simple hash, an array or a complex object with deeply nested data. Each validation is encapsulated by a simple, stateless predicate that receives some input and returns either true or false. Those predicates are encapsulated by rules which can be composed together using predicate logic, meaning you can use the familiar logic operators to build up a validation schema. Installation Add this to your application's shard.yml : dependencies : schema : github : azutoolkit/schem Usage require \"schema\" Defining Self Validated Schemas Schemas are defined as value objects, meaning structs, which are NOT mutable, making them ideal to pass schema objects as arguments to constructors. class Example include Schema :: Definition include Schema :: Validation property email : String property name : String property age : Int32 property alive : Bool property childrens : Array ( String ) property childrens_ages : Array ( Int32 ) property last_name : String use EmailValidator , UniqueRecordValidator validate :email , match : /\\w+@\\w+\\.\\w{2,3}/ , message : \"Email must be valid!\" validate :name , size : ( 1 .. 20 ) validate :age , gte : 18 , lte : 25 , message : \"Age must be 18 and 25 years old\" validate :alive , eq : true validate :last_name , presence : true , message : \"Last name is invalid\" predicates do def some? ( value : String , some ) : Bool ( ! value .nil? && value != \"\" ) && ! some .nil? end def if? ( value : Array ( Int32 ), bool : Bool ) : Bool ! bool end end def initialize ( @email , @name , @age , @alive , @childrens , @childrens_ages , @last_name ) end end Schema class methods Example . from_json Example . from_urlencoded ( \"&foo=bar\" ) # Any object that responds to `.each`, `#[]?`, `#[]`, `#fetch_all?` Example . new ( params ) Schema instance methods valid? - Bool validate! - True or Raise ValidationError errors - Errors ( T , S ) Example parsing HTTP Params (With nested params) Below find a list of the supported params parsing structure and it's corresponding representation in Query String or application/x-www-form-urlencoded form data. http_params = HTTP :: Params . build do | p | p . add ( \"string\" , \"string_value\" ) p . add ( \"optional_string\" , \"optional_string_value\" ) p . add ( \"string_with_default\" , \"string_with_default_value\" ) p . add ( \"int\" , \"1\" ) p . add ( \"optional_int\" , \"2\" ) p . add ( \"int_with_default\" , \"3\" ) p . add ( \"enum\" , \"Foo\" ) p . add ( \"optional_enum\" , \"Bar\" ) p . add ( \"enum_with_default\" , \"Baz\" ) p . add ( \"array[]\" , \"foo\" ) p . add ( \"array[]\" , \"bar\" ) p . add ( \"array[]\" , \"baz\" ) p . add ( \"optional_array[]\" , \"foo\" ) p . add ( \"optional_array[]\" , \"bar\" ) p . add ( \"array_with_default[]\" , \"foo\" ) p . add ( \"hash[foo]\" , \"1\" ) p . add ( \"hash[bar]\" , \"2\" ) p . add ( \"optional_hash[foo][]\" , \"3\" ) p . add ( \"optional_hash[foo][]\" , \"4\" ) p . add ( \"optional_hash[bar][]\" , \"5\" ) p . add ( \"hash_with_default[foo]\" , \"5\" ) p . add ( \"tuple[]\" , \"foo\" ) p . add ( \"tuple[]\" , \"2\" ) p . add ( \"tuple[]\" , \"3.5\" ) p . add ( \"boolean\" , \"1\" ) p . add ( \"optional_boolean\" , \"false\" ) p . add ( \"boolean_with_default\" , \"true\" ) p . add ( \"nested[foo]\" , \"1\" ) p . add ( \"nested[bar]\" , \"3\" ) p . add ( \"nested[baz][]\" , \"foo\" ) p . add ( \"nested[baz][]\" , \"bar\" ) end params = HTTP :: Params . parse ( \"email=test%40example.com&name=john&age=24&alive=true&childrens%5B%5D=Child1%2CChild2&childrens_ages%5B%5D=12&childrens_ages%5B%5D=18&address%5Bcity%5D=NY&address%5Bstreet%5D=Sleepy+Hollow&address%5Bzip%5D=12345&address%5Blocation%5D%5Blongitude%5D=41.085651&address%5Blocation%5D%5Blatitude%5D=-73.858467&address%5Blocation%5D%5Buseful%5D=true\" ) # HTTP::Params responds to `#[]`, `#[]?`, `#fetch_all?` and `.each` subject = ExampleController . new ( params ) Accessing the generated schemas: user = subject . user - Example address = user . address - Example :: Address location = address . location - Example :: Address :: Location Example parsing from JSON json = %({ \"user\": { \"email\": \"fake@example.com\", \"name\": \"Fake name\", \"age\": 25, \"alive\": true, \"childrens\": [\"Child 1\", \"Child 2\"], \"childrens_ages\": [9, 12] }}) user = Example . from_json ( json , \"user\" ) Validations You can also perform validations for existing objects without the use of Schemas. class User < Model include Schema :: Validation property email : String property name : String property age : Int32 property alive : Bool property childrens : Array ( String ) property childrens_ages : Array ( Int32 ) # To use a custom validator. UniqueRecordValidator will be initialized with an `User` instance use UniqueRecordValidator # Use the `custom` class name predicate as follow validate email , match : /\\w+@\\w+\\.\\w{2,3}/ , message : \"Email must be valid!\" , unique_record : true validate name , size : ( 1 .. 20 ) validate age , gte : 18 , lte : 25 , message : \"Must be 24 and 30 years old\" validate alive , eq : true def initialize ( @email , @name , @age , @alive , @childrens , @childrens_ages ) end end Custom Validations Simply create a class {Name}Validator with the following signature: class EmailValidator < Schema :: Validator getter :record , :field , :message def initialize ( @record : UserModel ) @field = :email @message = \"Email must be valid!\" end def valid? : Array ( Schema :: Error ) [] of Schema :: Error end end class UniqueRecordValidator < Schema :: Validator getter :record , :field , :message def initialize ( @record : UserModel ) @field = :email @message = \"Record must be unique!\" end def valid? : Array ( Schema :: Error ) [] of Schema :: Error end end Defining Predicates You can define your custom predicates by simply creating a custom validator or creating methods in the Schema::Predicates module ending with ? and it should return a boolean . For example: class User < Model property email : String property name : String property age : Int32 property alive : Bool property childrens : Array ( String ) property childrens_ages : Array ( Int32 ) ... # Uses a `presense` predicate validate password : String , presence : true # Use the `predicates` macro to define predicate methods predicates do # Presence Predicate Definition def presence? ( password : String , _other : String ) : Bool ! value .nil? end end def initialize ( @email , @name , @age , @alive , @childrens , @childrens_ages ) end end Differences: Custom Validator vs Predicates The differences between a custom validator and a method predicate are: Custom Validators - Must be inherited from Schema::Validator abstract - Receives an instance of the object as a record instance var. - Must have a :field and :message defined. - Must implement a def valid? : Array(Schema::Error) method. Predicates - Assertions of the property value against an expected value. - Predicates are light weight boolean methods. - Predicates methods must be defined as def {predicate}?(property_value, expected_value) : Bool . Built in Predicates These are the current available predicates. gte - Greater Than or Equal To lte - Less Than or Equal To gt - Greater Than lt - Less Than size - Size in - Inclusion regex - Regular Expression eq - Equal CONTRIBUTE - Add more predicates to this shards by contributing a Pull Request. Additional params message - Error message to display nilable - Allow nil , true or false Contributing Fork it ( https://github.com/azutoolkit/schemas/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request Contributors @eliasjpr Elias J. Perez - creator, maintainer","title":"Schema"},{"location":"schema/#schema","text":"Schemas come to solve a simple problem. Sometimes we would like to have type-safe guarantee parameters when parsing HTTP requests or Hash(String, String) for a request. Schema shard resolve precisely this problem with the added benefit of enabling self validating schemas that can be applied to any object, requiring little to no boilerplate code making you more productive from the moment you use this shard. Self validating Schemas are beneficial, and in my opinion, ideal, for when defining API Requests, Web Forms, JSON. Schema-Validation Takes a different approach and focuses a lot on explicitness, clarity, and precision of validation logic. It is designed to work with any data input, whether it\u2019s a simple hash, an array or a complex object with deeply nested data. Each validation is encapsulated by a simple, stateless predicate that receives some input and returns either true or false. Those predicates are encapsulated by rules which can be composed together using predicate logic, meaning you can use the familiar logic operators to build up a validation schema.","title":"Schema"},{"location":"schema/#installation","text":"Add this to your application's shard.yml : dependencies : schema : github : azutoolkit/schem","title":"Installation"},{"location":"schema/#usage","text":"require \"schema\"","title":"Usage"},{"location":"schema/#defining-self-validated-schemas","text":"Schemas are defined as value objects, meaning structs, which are NOT mutable, making them ideal to pass schema objects as arguments to constructors. class Example include Schema :: Definition include Schema :: Validation property email : String property name : String property age : Int32 property alive : Bool property childrens : Array ( String ) property childrens_ages : Array ( Int32 ) property last_name : String use EmailValidator , UniqueRecordValidator validate :email , match : /\\w+@\\w+\\.\\w{2,3}/ , message : \"Email must be valid!\" validate :name , size : ( 1 .. 20 ) validate :age , gte : 18 , lte : 25 , message : \"Age must be 18 and 25 years old\" validate :alive , eq : true validate :last_name , presence : true , message : \"Last name is invalid\" predicates do def some? ( value : String , some ) : Bool ( ! value .nil? && value != \"\" ) && ! some .nil? end def if? ( value : Array ( Int32 ), bool : Bool ) : Bool ! bool end end def initialize ( @email , @name , @age , @alive , @childrens , @childrens_ages , @last_name ) end end","title":"Defining Self Validated Schemas"},{"location":"schema/#schema-class-methods","text":"Example . from_json Example . from_urlencoded ( \"&foo=bar\" ) # Any object that responds to `.each`, `#[]?`, `#[]`, `#fetch_all?` Example . new ( params )","title":"Schema class methods"},{"location":"schema/#schema-instance-methods","text":"valid? - Bool validate! - True or Raise ValidationError errors - Errors ( T , S )","title":"Schema instance methods"},{"location":"schema/#example-parsing-http-params-with-nested-params","text":"Below find a list of the supported params parsing structure and it's corresponding representation in Query String or application/x-www-form-urlencoded form data. http_params = HTTP :: Params . build do | p | p . add ( \"string\" , \"string_value\" ) p . add ( \"optional_string\" , \"optional_string_value\" ) p . add ( \"string_with_default\" , \"string_with_default_value\" ) p . add ( \"int\" , \"1\" ) p . add ( \"optional_int\" , \"2\" ) p . add ( \"int_with_default\" , \"3\" ) p . add ( \"enum\" , \"Foo\" ) p . add ( \"optional_enum\" , \"Bar\" ) p . add ( \"enum_with_default\" , \"Baz\" ) p . add ( \"array[]\" , \"foo\" ) p . add ( \"array[]\" , \"bar\" ) p . add ( \"array[]\" , \"baz\" ) p . add ( \"optional_array[]\" , \"foo\" ) p . add ( \"optional_array[]\" , \"bar\" ) p . add ( \"array_with_default[]\" , \"foo\" ) p . add ( \"hash[foo]\" , \"1\" ) p . add ( \"hash[bar]\" , \"2\" ) p . add ( \"optional_hash[foo][]\" , \"3\" ) p . add ( \"optional_hash[foo][]\" , \"4\" ) p . add ( \"optional_hash[bar][]\" , \"5\" ) p . add ( \"hash_with_default[foo]\" , \"5\" ) p . add ( \"tuple[]\" , \"foo\" ) p . add ( \"tuple[]\" , \"2\" ) p . add ( \"tuple[]\" , \"3.5\" ) p . add ( \"boolean\" , \"1\" ) p . add ( \"optional_boolean\" , \"false\" ) p . add ( \"boolean_with_default\" , \"true\" ) p . add ( \"nested[foo]\" , \"1\" ) p . add ( \"nested[bar]\" , \"3\" ) p . add ( \"nested[baz][]\" , \"foo\" ) p . add ( \"nested[baz][]\" , \"bar\" ) end params = HTTP :: Params . parse ( \"email=test%40example.com&name=john&age=24&alive=true&childrens%5B%5D=Child1%2CChild2&childrens_ages%5B%5D=12&childrens_ages%5B%5D=18&address%5Bcity%5D=NY&address%5Bstreet%5D=Sleepy+Hollow&address%5Bzip%5D=12345&address%5Blocation%5D%5Blongitude%5D=41.085651&address%5Blocation%5D%5Blatitude%5D=-73.858467&address%5Blocation%5D%5Buseful%5D=true\" ) # HTTP::Params responds to `#[]`, `#[]?`, `#fetch_all?` and `.each` subject = ExampleController . new ( params ) Accessing the generated schemas: user = subject . user - Example address = user . address - Example :: Address location = address . location - Example :: Address :: Location","title":"Example parsing HTTP Params (With nested params)"},{"location":"schema/#example-parsing-from-json","text":"json = %({ \"user\": { \"email\": \"fake@example.com\", \"name\": \"Fake name\", \"age\": 25, \"alive\": true, \"childrens\": [\"Child 1\", \"Child 2\"], \"childrens_ages\": [9, 12] }}) user = Example . from_json ( json , \"user\" )","title":"Example parsing from JSON"},{"location":"schema/#validations","text":"You can also perform validations for existing objects without the use of Schemas. class User < Model include Schema :: Validation property email : String property name : String property age : Int32 property alive : Bool property childrens : Array ( String ) property childrens_ages : Array ( Int32 ) # To use a custom validator. UniqueRecordValidator will be initialized with an `User` instance use UniqueRecordValidator # Use the `custom` class name predicate as follow validate email , match : /\\w+@\\w+\\.\\w{2,3}/ , message : \"Email must be valid!\" , unique_record : true validate name , size : ( 1 .. 20 ) validate age , gte : 18 , lte : 25 , message : \"Must be 24 and 30 years old\" validate alive , eq : true def initialize ( @email , @name , @age , @alive , @childrens , @childrens_ages ) end end","title":"Validations"},{"location":"schema/#custom-validations","text":"Simply create a class {Name}Validator with the following signature: class EmailValidator < Schema :: Validator getter :record , :field , :message def initialize ( @record : UserModel ) @field = :email @message = \"Email must be valid!\" end def valid? : Array ( Schema :: Error ) [] of Schema :: Error end end class UniqueRecordValidator < Schema :: Validator getter :record , :field , :message def initialize ( @record : UserModel ) @field = :email @message = \"Record must be unique!\" end def valid? : Array ( Schema :: Error ) [] of Schema :: Error end end","title":"Custom Validations"},{"location":"schema/#defining-predicates","text":"You can define your custom predicates by simply creating a custom validator or creating methods in the Schema::Predicates module ending with ? and it should return a boolean . For example: class User < Model property email : String property name : String property age : Int32 property alive : Bool property childrens : Array ( String ) property childrens_ages : Array ( Int32 ) ... # Uses a `presense` predicate validate password : String , presence : true # Use the `predicates` macro to define predicate methods predicates do # Presence Predicate Definition def presence? ( password : String , _other : String ) : Bool ! value .nil? end end def initialize ( @email , @name , @age , @alive , @childrens , @childrens_ages ) end end","title":"Defining Predicates"},{"location":"schema/#differences-custom-validator-vs-predicates","text":"The differences between a custom validator and a method predicate are: Custom Validators - Must be inherited from Schema::Validator abstract - Receives an instance of the object as a record instance var. - Must have a :field and :message defined. - Must implement a def valid? : Array(Schema::Error) method. Predicates - Assertions of the property value against an expected value. - Predicates are light weight boolean methods. - Predicates methods must be defined as def {predicate}?(property_value, expected_value) : Bool .","title":"Differences: Custom Validator vs Predicates"},{"location":"schema/#built-in-predicates","text":"These are the current available predicates. gte - Greater Than or Equal To lte - Less Than or Equal To gt - Greater Than lt - Less Than size - Size in - Inclusion regex - Regular Expression eq - Equal CONTRIBUTE - Add more predicates to this shards by contributing a Pull Request. Additional params message - Error message to display nilable - Allow nil , true or false","title":"Built in Predicates"},{"location":"schema/#contributing","text":"Fork it ( https://github.com/azutoolkit/schemas/fork ) Create your feature branch ( git checkout -b my-new-feature ) Commit your changes ( git commit -am 'Add some feature' ) Push to the branch ( git push origin my-new-feature ) Create a new Pull Request","title":"Contributing"},{"location":"schema/#contributors","text":"@eliasjpr Elias J. Perez - creator, maintainer","title":"Contributors"},{"location":"azu/Azu/","text":"module Azu Constants CONFIG = Configuration . new","title":"Azu"},{"location":"azu/Azu/#Azu","text":"","title":"Azu"},{"location":"azu/Azu/#constants","text":"","title":"Constants"},{"location":"azu/Azu/#Azu::CONFIG","text":"","title":"CONFIG"},{"location":"azu/getting-started/","text":"Getting Started Environment Variables export CRYSTAL_ENV = development export CRYSTAL_LOG_SOURCES = \"*\" export CRYSTAL_LOG_LEVEL = DEBUG export CRYSTAL_WORKERS = 8 export PORT = 4000 export PORT_REUSE = true export HOST = 0 .0.0.0 export TEMPLATES_PATH = export ERROR_TEMPLATE = Define require \"azu\" module ExampleApp include Azu configure do | c | c . port = 4000 c . host = localhost c . port_reuse = true c . log = Log . for ( \"My Awesome App\" ) c . env = Environment :: Development c . template . path = \"./templates\" c . template . error_path = \"./error_template\" end end Endpoint Azu Endpoints are compose of a Request and Response objects, enabling strict typing. module ExampleApp class IndexEndpoint # Type Safe Endpoints include Endpoint ( IndexRequest , IndexResponse ) # Define the route for the endpoint get \"/hello/:name\" def call # Built in Error Types return BadRequest . new ( errors : req . errors . messages ) unless index_request . valid? status 200 content_type \"text/html\" header \"Custom\" , \"Fake custom header\" # ...call to domain layer... IndexPage . new index_request . name end end end Request Azu requests are contracts that you can validate module ExampleApp struct IndexRequest # Request Type include Request # Defines your request object expected properties # (query, form, path) macros are available query name : String , message : \"Param name must be string.\" , presence : true # Without type safe params you can access params # params.query[\"name\"] params is also available on Endpoints def name params . query [ \"name\" ] end end end Response Azu responses are define by including the Response module. module ExampleApp class IndexPclassage include Markup include Response include Templates :: Renderable def initialize ( @name : String ) end # Define HTML method for HTML Response def html # Uss built in html builder for folks # who enjoy html as code vs templates doctype body do a ( href : \"http://crystal-lang.org\" ) do text \" #{ @name } is awesome\" end end end end end Starts Server ExampleApp . start","title":"Getting Started"},{"location":"azu/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"azu/getting-started/#environment-variables","text":"export CRYSTAL_ENV = development export CRYSTAL_LOG_SOURCES = \"*\" export CRYSTAL_LOG_LEVEL = DEBUG export CRYSTAL_WORKERS = 8 export PORT = 4000 export PORT_REUSE = true export HOST = 0 .0.0.0 export TEMPLATES_PATH = export ERROR_TEMPLATE =","title":"Environment Variables"},{"location":"azu/getting-started/#define","text":"require \"azu\" module ExampleApp include Azu configure do | c | c . port = 4000 c . host = localhost c . port_reuse = true c . log = Log . for ( \"My Awesome App\" ) c . env = Environment :: Development c . template . path = \"./templates\" c . template . error_path = \"./error_template\" end end","title":"Define"},{"location":"azu/getting-started/#endpoint","text":"Azu Endpoints are compose of a Request and Response objects, enabling strict typing. module ExampleApp class IndexEndpoint # Type Safe Endpoints include Endpoint ( IndexRequest , IndexResponse ) # Define the route for the endpoint get \"/hello/:name\" def call # Built in Error Types return BadRequest . new ( errors : req . errors . messages ) unless index_request . valid? status 200 content_type \"text/html\" header \"Custom\" , \"Fake custom header\" # ...call to domain layer... IndexPage . new index_request . name end end end","title":"Endpoint"},{"location":"azu/getting-started/#request","text":"Azu requests are contracts that you can validate module ExampleApp struct IndexRequest # Request Type include Request # Defines your request object expected properties # (query, form, path) macros are available query name : String , message : \"Param name must be string.\" , presence : true # Without type safe params you can access params # params.query[\"name\"] params is also available on Endpoints def name params . query [ \"name\" ] end end end","title":"Request"},{"location":"azu/getting-started/#response","text":"Azu responses are define by including the Response module. module ExampleApp class IndexPclassage include Markup include Response include Templates :: Renderable def initialize ( @name : String ) end # Define HTML method for HTML Response def html # Uss built in html builder for folks # who enjoy html as code vs templates doctype body do a ( href : \"http://crystal-lang.org\" ) do text \" #{ @name } is awesome\" end end end end end","title":"Response"},{"location":"azu/getting-started/#starts-server","text":"ExampleApp . start","title":"Starts Server"},{"location":"azu/guiding-principle/","text":"Guiding Principles At its core, AZU Toolkit is lightweight, fast and expresive without locking you to a a specific pattern but instead offering the building blocks for your needs. Focus on your business domain, bring immediate productivity and long-term code maintainability. Simplicity Pre-existing knowledge of users to minimise their learning curve when using a module, so anything with high unpredictability factor is a good candidate for re-design Least Effort Everyone tends to follow the path that is as close to effortless as possible. Opportunity Cost To make a good economic decision, we want to choose the option with the greatest benefit to us but the lowest cost. Cost Of Delay Emphasises holding on taking important actions and crucial decisions for as long as possible. SOLID The SOLID principles do not only apply on software development but also when architecting a system.","title":"Guiding Principles"},{"location":"azu/guiding-principle/#guiding-principles","text":"At its core, AZU Toolkit is lightweight, fast and expresive without locking you to a a specific pattern but instead offering the building blocks for your needs. Focus on your business domain, bring immediate productivity and long-term code maintainability. Simplicity Pre-existing knowledge of users to minimise their learning curve when using a module, so anything with high unpredictability factor is a good candidate for re-design Least Effort Everyone tends to follow the path that is as close to effortless as possible. Opportunity Cost To make a good economic decision, we want to choose the option with the greatest benefit to us but the lowest cost. Cost Of Delay Emphasises holding on taking important actions and crucial decisions for as long as possible. SOLID The SOLID principles do not only apply on software development but also when architecting a system.","title":"Guiding Principles"},{"location":"azu/installation%20/","text":"Installation Install Crystal https://crystal-lang.org/install/ Add the dependency to your shard.yml : dependencies : azu : github : azutoolkit/azu Run shards install","title":"Installation"},{"location":"azu/installation%20/#installation","text":"Install Crystal https://crystal-lang.org/install/ Add the dependency to your shard.yml : dependencies : azu : github : azutoolkit/azu Run shards install","title":"Installation"},{"location":"azu/Azu/Channel/","text":"abstract class Azu::Channel inherits Reference A channel encapsulates a logical unit of work similar to an Endpoint. Channels are used for websocket connections that can handle multiple connections instances. A single client may have multiple WebSockets connections open to the application. Each channel can in turn broadcast to multiple connected clients You must setup a websocket route in your routing service ExampleApp . router do ws \"/hi\" , ExampleApp :: ExampleChannel end Direct known subclasses Azu::Spark Class methods .ws ( path : Router::Path ) View source .new ( socket : HTTP :: WebSocket ) View source Methods #call ( context : HTTP :: Server :: Context ) View source abstract #on_binary ( binary ) View source abstract #on_close ( code : HTTP :: WebSocket :: CloseCode | Int? = nil , message = nil ) View source abstract #on_connect View source abstract #on_message ( message ) View source abstract #on_ping ( message ) View source abstract #on_pong ( message ) View source #socket : HTTP :: WebSocket View source #socket? : HTTP :: WebSocket? View source","title":"Channel"},{"location":"azu/Azu/Channel/#Azu::Channel","text":"A channel encapsulates a logical unit of work similar to an Endpoint. Channels are used for websocket connections that can handle multiple connections instances. A single client may have multiple WebSockets connections open to the application. Each channel can in turn broadcast to multiple connected clients You must setup a websocket route in your routing service ExampleApp . router do ws \"/hi\" , ExampleApp :: ExampleChannel end","title":"Channel"},{"location":"azu/Azu/Channel/#direct-known-subclasses","text":"Azu::Spark","title":"Direct known subclasses"},{"location":"azu/Azu/Channel/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Channel/#Azu::Channel.ws(path)","text":"View source","title":".ws"},{"location":"azu/Azu/Channel/#Azu::Channel.new(socket)","text":"View source","title":".new"},{"location":"azu/Azu/Channel/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Channel/#Azu::Channel#call(context)","text":"View source","title":"#call"},{"location":"azu/Azu/Channel/#Azu::Channel#on_binary(binary)","text":"View source","title":"#on_binary"},{"location":"azu/Azu/Channel/#Azu::Channel#on_close(code,message)","text":"View source","title":"#on_close"},{"location":"azu/Azu/Channel/#Azu::Channel#on_connect()","text":"View source","title":"#on_connect"},{"location":"azu/Azu/Channel/#Azu::Channel#on_message(message)","text":"View source","title":"#on_message"},{"location":"azu/Azu/Channel/#Azu::Channel#on_ping(message)","text":"View source","title":"#on_ping"},{"location":"azu/Azu/Channel/#Azu::Channel#on_pong(message)","text":"View source","title":"#on_pong"},{"location":"azu/Azu/Channel/#Azu::Channel#socket()","text":"View source","title":"#socket"},{"location":"azu/Azu/Channel/#Azu::Channel#socket?()","text":"View source","title":"#socket?"},{"location":"azu/Azu/Component/","text":"module Azu::Component Included modules Azu::Markup Methods #connected= ( connected ) View source #connected? View source #content View source #every View source #id : String View source #mount View source #on_event ( name , data ) View source #refresh View source #refresh View source #render View source #socket= ( other ) View source #unmount View source","title":"Component"},{"location":"azu/Azu/Component/#Azu::Component","text":"","title":"Component"},{"location":"azu/Azu/Component/#included-modules","text":"Azu::Markup","title":"Included modules"},{"location":"azu/Azu/Component/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Component/#Azu::Component#connected=(connected)","text":"View source","title":"#connected="},{"location":"azu/Azu/Component/#Azu::Component#connected?()","text":"View source","title":"#connected?"},{"location":"azu/Azu/Component/#Azu::Component#content()","text":"View source","title":"#content"},{"location":"azu/Azu/Component/#Azu::Component#every(duration,&)","text":"View source","title":"#every"},{"location":"azu/Azu/Component/#Azu::Component#id()","text":"View source","title":"#id"},{"location":"azu/Azu/Component/#Azu::Component#mount()","text":"View source","title":"#mount"},{"location":"azu/Azu/Component/#Azu::Component#on_event(name,data)","text":"View source","title":"#on_event"},{"location":"azu/Azu/Component/#Azu::Component#refresh()","text":"View source","title":"#refresh"},{"location":"azu/Azu/Component/#Azu::Component#refresh()","text":"View source","title":"#refresh"},{"location":"azu/Azu/Component/#Azu::Component#render()","text":"View source","title":"#render"},{"location":"azu/Azu/Component/#Azu::Component#socket=(other)","text":"View source","title":"#socket="},{"location":"azu/Azu/Component/#Azu::Component#unmount()","text":"View source","title":"#unmount"},{"location":"azu/Azu/Configuration/","text":"class Azu::Configuration inherits Reference Holds all the configuration properties for your Azu Application Azu expects configurations to be loaded from environment variables for local development it is recommended to use .env files to store your development configuration properties. Azu . configure do | c | c . port = 4000 c . host = localhost c . port_reuse = true c . log = Log . for ( \"My Awesome App\" ) c . env = Environment :: Development c . template . path = \"./templates\" c . template . error_path = \"./error_template\" end Methods #env : Environment View source #env= ( env : Environment ) View source #host : String View source #host= ( host : String ) View source #log : Log View source #log= ( log : Log ) View source #port : Int32 View source #port= ( port : Int32 ) View source #port_reuse : Bool View source #port_reuse= ( port_reuse : Bool ) View source #router : Router View source #templates : Templates View source","title":"Configuration"},{"location":"azu/Azu/Configuration/#Azu::Configuration","text":"Holds all the configuration properties for your Azu Application Azu expects configurations to be loaded from environment variables for local development it is recommended to use .env files to store your development configuration properties. Azu . configure do | c | c . port = 4000 c . host = localhost c . port_reuse = true c . log = Log . for ( \"My Awesome App\" ) c . env = Environment :: Development c . template . path = \"./templates\" c . template . error_path = \"./error_template\" end","title":"Configuration"},{"location":"azu/Azu/Configuration/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Configuration/#Azu::Configuration#env()","text":"View source","title":"#env"},{"location":"azu/Azu/Configuration/#Azu::Configuration#env=(env)","text":"View source","title":"#env="},{"location":"azu/Azu/Configuration/#Azu::Configuration#host()","text":"View source","title":"#host"},{"location":"azu/Azu/Configuration/#Azu::Configuration#host=(host)","text":"View source","title":"#host="},{"location":"azu/Azu/Configuration/#Azu::Configuration#log()","text":"View source","title":"#log"},{"location":"azu/Azu/Configuration/#Azu::Configuration#log=(log)","text":"View source","title":"#log="},{"location":"azu/Azu/Configuration/#Azu::Configuration#port()","text":"View source","title":"#port"},{"location":"azu/Azu/Configuration/#Azu::Configuration#port=(port)","text":"View source","title":"#port="},{"location":"azu/Azu/Configuration/#Azu::Configuration#port_reuse()","text":"View source","title":"#port_reuse"},{"location":"azu/Azu/Configuration/#Azu::Configuration#port_reuse=(port_reuse)","text":"View source","title":"#port_reuse="},{"location":"azu/Azu/Configuration/#Azu::Configuration#router()","text":"View source","title":"#router"},{"location":"azu/Azu/Configuration/#Azu::Configuration#templates()","text":"View source","title":"#templates"},{"location":"azu/Azu/Endpoint/","text":"module Azu::Endpoint(Request, Response) Defines a Azu endpoint. The endpoint is the final stage of the request process Each endpoint is the location from which APIs can access the resources of your application to carry out their function. Azu endpoints is a simple module that defines the request and response object to execute your application business domain logic. Endpoints specify where resources can be accessed by APIs and the key role is to guarantee the correct functioning of the calls. Correctness To ensure correctness Azu Endpoints are design with the Request and Response pattern in mind you can think of it as input and output to a function, where the request is the input and the response is the output. Request and Response objects are type safe objects that can be designed by contract. Read more about Azu::Contract module ExampleApp class UserEndpoint include Azu :: Endpoint ( UserRequest , UserResponse ) end end Included modules HTTP::Handler Methods abstract #call : Response View source","title":"Endpoint"},{"location":"azu/Azu/Endpoint/#Azu::Endpoint","text":"Defines a Azu endpoint. The endpoint is the final stage of the request process Each endpoint is the location from which APIs can access the resources of your application to carry out their function. Azu endpoints is a simple module that defines the request and response object to execute your application business domain logic. Endpoints specify where resources can be accessed by APIs and the key role is to guarantee the correct functioning of the calls.","title":"Endpoint"},{"location":"azu/Azu/Endpoint/#Azu::Endpoint--correctness","text":"To ensure correctness Azu Endpoints are design with the Request and Response pattern in mind you can think of it as input and output to a function, where the request is the input and the response is the output. Request and Response objects are type safe objects that can be designed by contract. Read more about Azu::Contract module ExampleApp class UserEndpoint include Azu :: Endpoint ( UserRequest , UserResponse ) end end","title":"Correctness"},{"location":"azu/Azu/Endpoint/#included-modules","text":"HTTP::Handler","title":"Included modules"},{"location":"azu/Azu/Endpoint/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Endpoint/#Azu::Endpoint#call()","text":"View source","title":"#call"},{"location":"azu/Azu/Environment/","text":"enum Azu::Environment Allows to test which environment Azu is running in. The current application environment is determined via the CRYSTAL_ENV variable from your .env file. Members Build = 0 Build environment ideal for building images and compiling Development = 1 Development environment normally developer local development computer Test = 2 Test environment for running unit tests and component integration tests Integration = 3 Integration environment for running integration tests across network Acceptance = 4 Acceptance/System test environment to evaluate the system's compliance with the business requirements and assess whether it is acceptable for delivery Pipeline = 5 For running in a pipeline environment Staging = 6 Staging environment nearly exact replica of a production environment for software testing Production = 7 where software and other products are actually put into operation for their intended uses by end users Methods #acceptance? View source #build? View source #development? View source #in? ( environments : Array ( Symbol )) Checks if the current environment is in any of the environment listed View source #in? ( * environments : Environment ) Checks if the current environment matches another environment View source #integration? View source #pipeline? View source #production? View source #staging? View source #test? View source","title":"Environment"},{"location":"azu/Azu/Environment/#Azu::Environment","text":"Allows to test which environment Azu is running in. The current application environment is determined via the CRYSTAL_ENV variable from your .env file.","title":"Environment"},{"location":"azu/Azu/Environment/#members","text":"","title":"Members"},{"location":"azu/Azu/Environment/#Azu::Environment::Build","text":"Build environment ideal for building images and compiling","title":"Build"},{"location":"azu/Azu/Environment/#Azu::Environment::Development","text":"Development environment normally developer local development computer","title":"Development"},{"location":"azu/Azu/Environment/#Azu::Environment::Test","text":"Test environment for running unit tests and component integration tests","title":"Test"},{"location":"azu/Azu/Environment/#Azu::Environment::Integration","text":"Integration environment for running integration tests across network","title":"Integration"},{"location":"azu/Azu/Environment/#Azu::Environment::Acceptance","text":"Acceptance/System test environment to evaluate the system's compliance with the business requirements and assess whether it is acceptable for delivery","title":"Acceptance"},{"location":"azu/Azu/Environment/#Azu::Environment::Pipeline","text":"For running in a pipeline environment","title":"Pipeline"},{"location":"azu/Azu/Environment/#Azu::Environment::Staging","text":"Staging environment nearly exact replica of a production environment for software testing","title":"Staging"},{"location":"azu/Azu/Environment/#Azu::Environment::Production","text":"where software and other products are actually put into operation for their intended uses by end users","title":"Production"},{"location":"azu/Azu/Environment/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Environment/#Azu::Environment#acceptance?()","text":"View source","title":"#acceptance?"},{"location":"azu/Azu/Environment/#Azu::Environment#build?()","text":"View source","title":"#build?"},{"location":"azu/Azu/Environment/#Azu::Environment#development?()","text":"View source","title":"#development?"},{"location":"azu/Azu/Environment/#Azu::Environment#in?(environments)","text":"Checks if the current environment is in any of the environment listed View source","title":"#in?"},{"location":"azu/Azu/Environment/#Azu::Environment#integration?()","text":"View source","title":"#integration?"},{"location":"azu/Azu/Environment/#Azu::Environment#pipeline?()","text":"View source","title":"#pipeline?"},{"location":"azu/Azu/Environment/#Azu::Environment#production?()","text":"View source","title":"#production?"},{"location":"azu/Azu/Environment/#Azu::Environment#staging?()","text":"View source","title":"#staging?"},{"location":"azu/Azu/Environment/#Azu::Environment#test?()","text":"View source","title":"#test?"},{"location":"azu/Azu/Handler/","text":"module Azu::Handler","title":"Handler"},{"location":"azu/Azu/Handler/#Azu::Handler","text":"","title":"Handler"},{"location":"azu/Azu/Markup/","text":"module Azu::Markup Allows you to write HTML markup in plain crystal code Direct including types Azu::Component Methods #to_s ( io : IO ) : Nil View source","title":"Markup"},{"location":"azu/Azu/Markup/#Azu::Markup","text":"Allows you to write HTML markup in plain crystal code","title":"Markup"},{"location":"azu/Azu/Markup/#direct-including-types","text":"Azu::Component","title":"Direct including types"},{"location":"azu/Azu/Markup/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Markup/#Azu::Markup#to_s(io)","text":"View source","title":"#to_s"},{"location":"azu/Azu/Params/","text":"class Azu::Params(Request) inherits Reference Constants APPLICATION_JSON = \"application/json\" CONTENT_TYPE = \"Content-Type\" MULTIPART_FORM = \"multipart/form-data\" URL_ENCODED_FORM = \"application/x-www-form-urlencoded\" Class methods .new ( request : HTTP :: Request ) View source Methods #[] ( key ) View source #[]? ( key ) View source #each View source #fetch_all ( key ) View source #files View source #form : HTTP :: Params View source #json : String? View source #path : Hash ( String , String ) View source #query : HTTP :: Params View source #request : Request? View source #to_h View source","title":"Params"},{"location":"azu/Azu/Params/#Azu::Params","text":"","title":"Params"},{"location":"azu/Azu/Params/#constants","text":"","title":"Constants"},{"location":"azu/Azu/Params/#Azu::Params::APPLICATION_JSON","text":"","title":"APPLICATION_JSON"},{"location":"azu/Azu/Params/#Azu::Params::CONTENT_TYPE","text":"","title":"CONTENT_TYPE"},{"location":"azu/Azu/Params/#Azu::Params::MULTIPART_FORM","text":"","title":"MULTIPART_FORM"},{"location":"azu/Azu/Params/#Azu::Params::URL_ENCODED_FORM","text":"","title":"URL_ENCODED_FORM"},{"location":"azu/Azu/Params/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Params/#Azu::Params.new(request)","text":"View source","title":".new"},{"location":"azu/Azu/Params/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Params/#Azu::Params#[](key)","text":"View source","title":"#[]"},{"location":"azu/Azu/Params/#Azu::Params#[]?(key)","text":"View source","title":"#[]?"},{"location":"azu/Azu/Params/#Azu::Params#each()","text":"View source","title":"#each"},{"location":"azu/Azu/Params/#Azu::Params#fetch_all(key)","text":"View source","title":"#fetch_all"},{"location":"azu/Azu/Params/#Azu::Params#files()","text":"View source","title":"#files"},{"location":"azu/Azu/Params/#Azu::Params#form()","text":"View source","title":"#form"},{"location":"azu/Azu/Params/#Azu::Params#json()","text":"View source","title":"#json"},{"location":"azu/Azu/Params/#Azu::Params#path()","text":"View source","title":"#path"},{"location":"azu/Azu/Params/#Azu::Params#query()","text":"View source","title":"#query"},{"location":"azu/Azu/Params/#Azu::Params#request()","text":"View source","title":"#request"},{"location":"azu/Azu/Params/#Azu::Params#to_h()","text":"View source","title":"#to_h"},{"location":"azu/Azu/Request/","text":"module Azu::Request Every HTTP request message has a specific form: POST /path HTTP/1.1 Host: example.com foo=bar&baz=bat A HTTP message is either a request from a client to a server or a response from a server to a client The Azu::Request represents a client request and it provides additional helper methods to access different parts of the HTTP Request extending the Crystal HTTP::Request standard library class. These methods are define in the Helpers class. Azu Request are design by contract in order to enforce correctness. What this means is that requests are strictly typed and can have pre-conditions. With this concept Azu::Request provides a consice way to type safe and validate requests objects. Azu Requests benefits: Self documented request objects. Type safe requests and parameters Enables Focused and effective testing. Json body requests render object instances. Azu Requests contracts is provided by tight integration with the Schema shard Example Use: class UserRequest include Azu :: Request query name : String , message : \"Param name must be present.\" , presence : true end Initializers UserRequest . from_json ( pyaload : String ) UserRequest . new ( params : Hash ( String , String )) Available Methods getters - For each of the params valid? - Bool validate! - True or Raise Error errors - Errors ( T , S ) rules - Rules ( T , S ) params - Original params payload to_json - Outputs JSON to_yaml - Outputs YAML","title":"Request"},{"location":"azu/Azu/Request/#Azu::Request","text":"Every HTTP request message has a specific form: POST /path HTTP/1.1 Host: example.com foo=bar&baz=bat A HTTP message is either a request from a client to a server or a response from a server to a client The Azu::Request represents a client request and it provides additional helper methods to access different parts of the HTTP Request extending the Crystal HTTP::Request standard library class. These methods are define in the Helpers class. Azu Request are design by contract in order to enforce correctness. What this means is that requests are strictly typed and can have pre-conditions. With this concept Azu::Request provides a consice way to type safe and validate requests objects. Azu Requests benefits: Self documented request objects. Type safe requests and parameters Enables Focused and effective testing. Json body requests render object instances. Azu Requests contracts is provided by tight integration with the Schema shard","title":"Request"},{"location":"azu/Azu/Request/#Azu::Request--example-use","text":"class UserRequest include Azu :: Request query name : String , message : \"Param name must be present.\" , presence : true end","title":"Example Use:"},{"location":"azu/Azu/Request/#Azu::Request--initializers","text":"UserRequest . from_json ( pyaload : String ) UserRequest . new ( params : Hash ( String , String ))","title":"Initializers"},{"location":"azu/Azu/Request/#Azu::Request--available-methods","text":"getters - For each of the params valid? - Bool validate! - True or Raise Error errors - Errors ( T , S ) rules - Rules ( T , S ) params - Original params payload to_json - Outputs JSON to_yaml - Outputs YAML","title":"Available Methods"},{"location":"azu/Azu/Response/","text":"module Azu::Response A response is a message sent from a server to a client Azu:Response represents an interface for all Azu server responses. You can still use Crystal HTTP::Response class to generete response messages. The response #status and #headers must be configured before writing the response body. Once response output is written, changing the #status and #headers properties has no effect. Defining Responses module MyApp class Home:: Page include Response :: Html TEMPLATE_PATH = \"home/index.jinja\" def html render TEMPLATE_PATH , assigns end def assigns { \"welcome\" => \"Hello World!\" , } end end end Direct including types Azu::Response::Error Methods abstract #render View source","title":"Response"},{"location":"azu/Azu/Response/#Azu::Response","text":"A response is a message sent from a server to a client Azu:Response represents an interface for all Azu server responses. You can still use Crystal HTTP::Response class to generete response messages. The response #status and #headers must be configured before writing the response body. Once response output is written, changing the #status and #headers properties has no effect.","title":"Response"},{"location":"azu/Azu/Response/#Azu::Response--defining-responses","text":"module MyApp class Home:: Page include Response :: Html TEMPLATE_PATH = \"home/index.jinja\" def html render TEMPLATE_PATH , assigns end def assigns { \"welcome\" => \"Hello World!\" , } end end end","title":"Defining Responses"},{"location":"azu/Azu/Response/#direct-including-types","text":"Azu::Response::Error","title":"Direct including types"},{"location":"azu/Azu/Response/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Response/#Azu::Response#render()","text":"View source","title":"#render"},{"location":"azu/Azu/Router/","text":"class Azu::Router inherits Reference Azu routing class that allows you to define routes for your application. ExampleApp . router do root :web , ExampleApp :: HelloWorld ws \"/hi\" , ExampleApp :: ExampleChannel routes :web , \"/test\" do get \"/hello/\" , ExampleApp :: HelloWorld get \"/hello/:name\" , ExampleApp :: HtmlEndpoint get \"/hello/json\" , ExampleApp :: JsonEndpoint end end Constants RADIX = Radix :: Tree ( Route ) . new RESOURCES = [ \"connect\" , \"delete\" , \"get\" , \"head\" , \"options\" , \"patch\" , \"post\" , \"put\" , \"trace\" ] of :: String Methods #add ( path : Path , endpoint : HTTP :: Handler , method : Method = Method :: Any ) Registers a route for a given path View source #connect ( path : Router::Path , handler : HTTP :: Handler ) View source #delete ( path : Router::Path , handler : HTTP :: Handler ) View source #get ( path : Router::Path , handler : HTTP :: Handler ) View source #head ( path : Router::Path , handler : HTTP :: Handler ) View source #options ( path : Router::Path , handler : HTTP :: Handler ) View source #patch ( path : Router::Path , handler : HTTP :: Handler ) View source #post ( path : Router::Path , handler : HTTP :: Handler ) View source #process ( context : HTTP :: Server :: Context ) View source #put ( path : Router::Path , handler : HTTP :: Handler ) View source #root ( endpoint : HTTP :: Handler ) Registers the main route of the application root :web , ExampleApp :: HelloWorld View source #routes ( scope : String = \"\" View source #trace ( path : Router::Path , handler : HTTP :: Handler ) View source #ws ( path : String , channel : Channel . class ) Registers a websocket route ws \"/hi\" , ExampleApp :: ExampleChannel View source","title":"Router"},{"location":"azu/Azu/Router/#Azu::Router","text":"Azu routing class that allows you to define routes for your application. ExampleApp . router do root :web , ExampleApp :: HelloWorld ws \"/hi\" , ExampleApp :: ExampleChannel routes :web , \"/test\" do get \"/hello/\" , ExampleApp :: HelloWorld get \"/hello/:name\" , ExampleApp :: HtmlEndpoint get \"/hello/json\" , ExampleApp :: JsonEndpoint end end","title":"Router"},{"location":"azu/Azu/Router/#constants","text":"","title":"Constants"},{"location":"azu/Azu/Router/#Azu::Router::RADIX","text":"","title":"RADIX"},{"location":"azu/Azu/Router/#Azu::Router::RESOURCES","text":"","title":"RESOURCES"},{"location":"azu/Azu/Router/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Router/#Azu::Router#add(path,endpoint,method)","text":"Registers a route for a given path View source","title":"#add"},{"location":"azu/Azu/Router/#Azu::Router#connect(path,handler)","text":"View source","title":"#connect"},{"location":"azu/Azu/Router/#Azu::Router#delete(path,handler)","text":"View source","title":"#delete"},{"location":"azu/Azu/Router/#Azu::Router#get(path,handler)","text":"View source","title":"#get"},{"location":"azu/Azu/Router/#Azu::Router#head(path,handler)","text":"View source","title":"#head"},{"location":"azu/Azu/Router/#Azu::Router#options(path,handler)","text":"View source","title":"#options"},{"location":"azu/Azu/Router/#Azu::Router#patch(path,handler)","text":"View source","title":"#patch"},{"location":"azu/Azu/Router/#Azu::Router#post(path,handler)","text":"View source","title":"#post"},{"location":"azu/Azu/Router/#Azu::Router#process(context)","text":"View source","title":"#process"},{"location":"azu/Azu/Router/#Azu::Router#put(path,handler)","text":"View source","title":"#put"},{"location":"azu/Azu/Router/#Azu::Router#root(endpoint)","text":"Registers the main route of the application root :web , ExampleApp :: HelloWorld View source","title":"#root"},{"location":"azu/Azu/Router/#Azu::Router#routes(scope)","text":"View source","title":"#routes"},{"location":"azu/Azu/Router/#Azu::Router#trace(path,handler)","text":"View source","title":"#trace"},{"location":"azu/Azu/Router/#Azu::Router#ws(path,channel)","text":"Registers a websocket route ws \"/hi\" , ExampleApp :: ExampleChannel View source","title":"#ws"},{"location":"azu/Azu/Spark/","text":"class Azu::Spark inherits Azu::Channel Constants COMPONENTS = {} of String => Component Class methods .javascript_tag View source Methods #on_binary ( binary ) View source #on_close ( code : HTTP :: WebSocket :: CloseCode | Int? = nil , message = nil ) View source #on_connect View source #on_message ( message ) View source #on_ping ( message ) View source #on_pong ( message ) View source","title":"Spark"},{"location":"azu/Azu/Spark/#Azu::Spark","text":"","title":"Spark"},{"location":"azu/Azu/Spark/#constants","text":"","title":"Constants"},{"location":"azu/Azu/Spark/#Azu::Spark::COMPONENTS","text":"","title":"COMPONENTS"},{"location":"azu/Azu/Spark/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Spark/#Azu::Spark.javascript_tag()","text":"View source","title":".javascript_tag"},{"location":"azu/Azu/Spark/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Spark/#Azu::Spark#on_binary(binary)","text":"View source","title":"#on_binary"},{"location":"azu/Azu/Spark/#Azu::Spark#on_close(code,message)","text":"View source","title":"#on_close"},{"location":"azu/Azu/Spark/#Azu::Spark#on_connect()","text":"View source","title":"#on_connect"},{"location":"azu/Azu/Spark/#Azu::Spark#on_message(message)","text":"View source","title":"#on_message"},{"location":"azu/Azu/Spark/#Azu::Spark#on_ping(message)","text":"View source","title":"#on_ping"},{"location":"azu/Azu/Spark/#Azu::Spark#on_pong(message)","text":"View source","title":"#on_pong"},{"location":"azu/Azu/Templates/","text":"class Azu::Templates inherits Reference Templates are used by Azu when rendering responses. Since many views render significant content, for example a whole HTML file, it is common to put these files into a particular directory, typically \"src/templates\". This module provides conveniences for reading all files from a particular directory and embedding them into a single module. Imagine you have a directory with templates: Templates::Renderable will define a private function named render(template : String, data) with one clause per file system template. render ( template : String , data ) Class methods .new ( path : String , error_path : String ) View source Methods #error_path : String View source #error_path= ( path : String ) View source #load ( template : String ) View source #path : String View source #path= ( path : String ) View source","title":"Templates"},{"location":"azu/Azu/Templates/#Azu::Templates","text":"Templates are used by Azu when rendering responses. Since many views render significant content, for example a whole HTML file, it is common to put these files into a particular directory, typically \"src/templates\". This module provides conveniences for reading all files from a particular directory and embedding them into a single module. Imagine you have a directory with templates: Templates::Renderable will define a private function named render(template : String, data) with one clause per file system template. render ( template : String , data )","title":"Templates"},{"location":"azu/Azu/Templates/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Templates/#Azu::Templates.new(path,error_path)","text":"View source","title":".new"},{"location":"azu/Azu/Templates/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Templates/#Azu::Templates#error_path()","text":"View source","title":"#error_path"},{"location":"azu/Azu/Templates/#Azu::Templates#error_path=(path)","text":"View source","title":"#error_path="},{"location":"azu/Azu/Templates/#Azu::Templates#load(template)","text":"View source","title":"#load"},{"location":"azu/Azu/Templates/#Azu::Templates#path()","text":"View source","title":"#path"},{"location":"azu/Azu/Templates/#Azu::Templates#path=(path)","text":"View source","title":"#path="},{"location":"azu/Azu/Handler/IpSpoofing/","text":"class Azu::Handler::IpSpoofing inherits Reference IP spoofing is the creation of Internet Protocol (IP) packets which have a modified source address in order to either hide the identity of the sender, to impersonate another computer system, or both. It is a technique often used by bad actors to invoke DDoS attacks against a target device or the surrounding infrastructure. Usage Azu :: Throttle . new Included modules HTTP::Handler Constants CLIENT_IP = \"X-Client-IP\" FORWARDED_FOR = \"X-Forwarded-For\" REAL_IP = \"X-Real-IP\" Methods #call ( context : HTTP :: Server :: Context ) View source","title":"IpSpoofing"},{"location":"azu/Azu/Handler/IpSpoofing/#Azu::Handler::IpSpoofing","text":"IP spoofing is the creation of Internet Protocol (IP) packets which have a modified source address in order to either hide the identity of the sender, to impersonate another computer system, or both. It is a technique often used by bad actors to invoke DDoS attacks against a target device or the surrounding infrastructure.","title":"IpSpoofing"},{"location":"azu/Azu/Handler/IpSpoofing/#Azu::Handler::IpSpoofing--usage","text":"Azu :: Throttle . new","title":"Usage"},{"location":"azu/Azu/Handler/IpSpoofing/#included-modules","text":"HTTP::Handler","title":"Included modules"},{"location":"azu/Azu/Handler/IpSpoofing/#constants","text":"","title":"Constants"},{"location":"azu/Azu/Handler/IpSpoofing/#Azu::Handler::IpSpoofing::CLIENT_IP","text":"","title":"CLIENT_IP"},{"location":"azu/Azu/Handler/IpSpoofing/#Azu::Handler::IpSpoofing::FORWARDED_FOR","text":"","title":"FORWARDED_FOR"},{"location":"azu/Azu/Handler/IpSpoofing/#Azu::Handler::IpSpoofing::REAL_IP","text":"","title":"REAL_IP"},{"location":"azu/Azu/Handler/IpSpoofing/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Handler/IpSpoofing/#Azu::Handler::IpSpoofing#call(context)","text":"View source","title":"#call"},{"location":"azu/Azu/Handler/Logger/","text":"class Azu::Handler::Logger inherits Reference Included modules HTTP::Handler Class methods .new ( log : Log = CONFIG . log ) View source Methods #call ( context : HTTP :: Server :: Context ) View source #log : Log View source","title":"Logger"},{"location":"azu/Azu/Handler/Logger/#Azu::Handler::Logger","text":"","title":"Logger"},{"location":"azu/Azu/Handler/Logger/#included-modules","text":"HTTP::Handler","title":"Included modules"},{"location":"azu/Azu/Handler/Logger/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Handler/Logger/#Azu::Handler::Logger.new(log)","text":"View source","title":".new"},{"location":"azu/Azu/Handler/Logger/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Handler/Logger/#Azu::Handler::Logger#call(context)","text":"View source","title":"#call"},{"location":"azu/Azu/Handler/Logger/#Azu::Handler::Logger#log()","text":"View source","title":"#log"},{"location":"azu/Azu/Handler/Rescuer/","text":"class Azu::Handler::Rescuer inherits Reference Included modules HTTP::Handler Class methods .new ( log = Log . for ( \"http.server\" )) View source Methods #call ( context : HTTP :: Server :: Context ) View source","title":"Rescuer"},{"location":"azu/Azu/Handler/Rescuer/#Azu::Handler::Rescuer","text":"","title":"Rescuer"},{"location":"azu/Azu/Handler/Rescuer/#included-modules","text":"HTTP::Handler","title":"Included modules"},{"location":"azu/Azu/Handler/Rescuer/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Handler/Rescuer/#Azu::Handler::Rescuer.new(log)","text":"View source","title":".new"},{"location":"azu/Azu/Handler/Rescuer/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Handler/Rescuer/#Azu::Handler::Rescuer#call(context)","text":"View source","title":"#call"},{"location":"azu/Azu/Handler/Static/","text":"class Azu::Handler::Static inherits HTTP::StaticFileHandler Constants ZIPPED_FILE_EXTENSIONS = [ \".htm\" , \".html\" , \".txt\" , \".css\" , \".js\" , \".svg\" , \".json\" , \".xml\" , \".otf\" , \".ttf\" , \".woff\" , \".woff2\" ] of :: String Class methods .new ( public_dir : String = \"public\" , fallthrough = false , directory_listing = false ) View source Methods #call ( context : HTTP :: Server :: Context ) View source","title":"Static"},{"location":"azu/Azu/Handler/Static/#Azu::Handler::Static","text":"","title":"Static"},{"location":"azu/Azu/Handler/Static/#constants","text":"","title":"Constants"},{"location":"azu/Azu/Handler/Static/#Azu::Handler::Static::ZIPPED_FILE_EXTENSIONS","text":"","title":"ZIPPED_FILE_EXTENSIONS"},{"location":"azu/Azu/Handler/Static/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Handler/Static/#Azu::Handler::Static.new(public_dir,fallthrough,directory_listing)","text":"View source","title":".new"},{"location":"azu/Azu/Handler/Static/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Handler/Static/#Azu::Handler::Static#call(context)","text":"View source","title":"#call"},{"location":"azu/Azu/Handler/Throttle/","text":"class Azu::Handler::Throttle inherits Reference Handler for protecting against Denial-of-service attacks and/or to rate limit requests. DDoS errors occur when the client is sending too many requests at once. these attacks are essentially rate-limiting problems. By blocking a certain IP address, or allowing a certain IP address to make a limited number of requests over a certain period of time, you are building the first line of defense in blocking DDoS attacks. http://en.wikipedia.org/wiki/Denial-of-service_attack . Options interval Duration in seconds until the request counter is reset. Defaults to 5 duration Duration in seconds that a remote address will be blocked. Defaults to 900 (15 minutes) threshold Number of requests allowed. Defaults to 100 blacklist Array of remote addresses immediately considered malicious. whitelist Array of remote addresses which bypass Deflect. Usage Azu :: Throttle . new ( interval : 5 , duration : 5 , threshold : 10 , blacklist : [ \"111.111.111.111\" ] , whitelist : [ \"222.222.222.222\" ] ) Included modules HTTP::Handler Constants CONTENT_LENGTH = \"Content-Length\" CONTENT_TYPE = \"Content-Type\" MAPPER = {} of String => Hash ( String , Int32 | Int64 ) REMOTE_ADDR = \"REMOTE_ADDR\" RETRY_AFTER = \"Retry-After\" Class methods .new ( interval , duration , threshold , blacklist , whitelist ) View source Methods #call ( context : HTTP :: Server :: Context ) View source","title":"Throttle"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle","text":"Handler for protecting against Denial-of-service attacks and/or to rate limit requests. DDoS errors occur when the client is sending too many requests at once. these attacks are essentially rate-limiting problems. By blocking a certain IP address, or allowing a certain IP address to make a limited number of requests over a certain period of time, you are building the first line of defense in blocking DDoS attacks. http://en.wikipedia.org/wiki/Denial-of-service_attack .","title":"Throttle"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle--options","text":"interval Duration in seconds until the request counter is reset. Defaults to 5 duration Duration in seconds that a remote address will be blocked. Defaults to 900 (15 minutes) threshold Number of requests allowed. Defaults to 100 blacklist Array of remote addresses immediately considered malicious. whitelist Array of remote addresses which bypass Deflect.","title":"Options"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle--usage","text":"Azu :: Throttle . new ( interval : 5 , duration : 5 , threshold : 10 , blacklist : [ \"111.111.111.111\" ] , whitelist : [ \"222.222.222.222\" ] )","title":"Usage"},{"location":"azu/Azu/Handler/Throttle/#included-modules","text":"HTTP::Handler","title":"Included modules"},{"location":"azu/Azu/Handler/Throttle/#constants","text":"","title":"Constants"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle::CONTENT_LENGTH","text":"","title":"CONTENT_LENGTH"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle::CONTENT_TYPE","text":"","title":"CONTENT_TYPE"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle::MAPPER","text":"","title":"MAPPER"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle::REMOTE_ADDR","text":"","title":"REMOTE_ADDR"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle::RETRY_AFTER","text":"","title":"RETRY_AFTER"},{"location":"azu/Azu/Handler/Throttle/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle.new(interval,duration,threshold,blacklist,whitelist)","text":"View source","title":".new"},{"location":"azu/Azu/Handler/Throttle/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Handler/Throttle/#Azu::Handler::Throttle#call(context)","text":"View source","title":"#call"},{"location":"azu/Azu/Params/Form/","text":"module Azu::Params::Form Class methods .parse ( request : HTTP :: Request ) View source .parse_part ( input : IO ) : HTTP :: Params View source .parse_part ( input : String ) : HTTP :: Params View source .parse_part ( input : Nil ) : HTTP :: Params View source","title":"Form"},{"location":"azu/Azu/Params/Form/#Azu::Params::Form","text":"","title":"Form"},{"location":"azu/Azu/Params/Form/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Params/Form/#Azu::Params::Form.parse(request)","text":"View source","title":".parse"},{"location":"azu/Azu/Params/Form/#Azu::Params::Form.parse_part(input)","text":"View source","title":".parse_part"},{"location":"azu/Azu/Params/Form/#Azu::Params::Form.parse_part(input)","text":"View source","title":".parse_part"},{"location":"azu/Azu/Params/Form/#Azu::Params::Form.parse_part(input)","text":"View source","title":".parse_part"},{"location":"azu/Azu/Params/Multipart/","text":"module Azu::Params::Multipart Class methods .parse ( request : HTTP :: Request ) View source","title":"Multipart"},{"location":"azu/Azu/Params/Multipart/#Azu::Params::Multipart","text":"","title":"Multipart"},{"location":"azu/Azu/Params/Multipart/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Params/Multipart/#Azu::Params::Multipart.parse(request)","text":"View source","title":".parse"},{"location":"azu/Azu/Params/Multipart/File/","text":"struct Azu::Params::Multipart::File inherits Struct Class methods .new ( upload ) View source Methods #creation_time : Time? View source #file : :: File View source #filename : String? View source #headers : HTTP :: Headers View source #modification_time : Time? View source #read_time : Time? View source #size : UInt64? View source","title":"File"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File","text":"","title":"File"},{"location":"azu/Azu/Params/Multipart/File/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File.new(upload)","text":"View source","title":".new"},{"location":"azu/Azu/Params/Multipart/File/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File#creation_time()","text":"View source","title":"#creation_time"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File#file()","text":"View source","title":"#file"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File#filename()","text":"View source","title":"#filename"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File#headers()","text":"View source","title":"#headers"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File#modification_time()","text":"View source","title":"#modification_time"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File#read_time()","text":"View source","title":"#read_time"},{"location":"azu/Azu/Params/Multipart/File/#Azu::Params::Multipart::File#size()","text":"View source","title":"#size"},{"location":"azu/Azu/Response/BadRequest/","text":"class Azu::Response::BadRequest inherits Azu::Response::Error Methods #detail : String View source #status : HTTP :: Status View source #title : String View source","title":"BadRequest"},{"location":"azu/Azu/Response/BadRequest/#Azu::Response::BadRequest","text":"","title":"BadRequest"},{"location":"azu/Azu/Response/BadRequest/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Response/BadRequest/#Azu::Response::BadRequest#detail()","text":"View source","title":"#detail"},{"location":"azu/Azu/Response/BadRequest/#Azu::Response::BadRequest#status()","text":"View source","title":"#status"},{"location":"azu/Azu/Response/BadRequest/#Azu::Response::BadRequest#title()","text":"View source","title":"#title"},{"location":"azu/Azu/Response/Error/","text":"class Azu::Response::Error inherits Exception Included modules Azu::Response Direct known subclasses Azu::Response::BadRequest Azu::Response::Forbidden Azu::Response::NotFound Class methods .from_exception ( ex , status = 500 ) View source .new ( title , status , errors ) View source Methods #detail : String View source #detail= ( detail : String ) View source #errors : Array ( String ) View source #errors= ( errors : Array ( String )) View source #html ( context ) View source #html View source #json View source #link View source #render ( template : String , data ) View source #render View source #source : String View source #source= ( source : String ) View source #status : HTTP :: Status View source #status= ( status : HTTP :: Status ) View source #status_code View source #text View source #title : String View source #title= ( title : String ) View source #to_s ( context : HTTP :: Server :: Context ) View source #xml View source","title":"Error"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error","text":"","title":"Error"},{"location":"azu/Azu/Response/Error/#included-modules","text":"Azu::Response","title":"Included modules"},{"location":"azu/Azu/Response/Error/#direct-known-subclasses","text":"Azu::Response::BadRequest Azu::Response::Forbidden Azu::Response::NotFound","title":"Direct known subclasses"},{"location":"azu/Azu/Response/Error/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error.from_exception(ex,status)","text":"View source","title":".from_exception"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error.new(title,status,errors)","text":"View source","title":".new"},{"location":"azu/Azu/Response/Error/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#detail()","text":"View source","title":"#detail"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#detail=(detail)","text":"View source","title":"#detail="},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#errors()","text":"View source","title":"#errors"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#errors=(errors)","text":"View source","title":"#errors="},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#html(context)","text":"View source","title":"#html"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#json()","text":"View source","title":"#json"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#link()","text":"View source","title":"#link"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#render(template,data)","text":"View source","title":"#render"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#source()","text":"View source","title":"#source"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#source=(source)","text":"View source","title":"#source="},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#status()","text":"View source","title":"#status"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#status=(status)","text":"View source","title":"#status="},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#status_code()","text":"View source","title":"#status_code"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#text()","text":"View source","title":"#text"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#title()","text":"View source","title":"#title"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#title=(title)","text":"View source","title":"#title="},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#to_s(context)","text":"View source","title":"#to_s"},{"location":"azu/Azu/Response/Error/#Azu::Response::Error#xml()","text":"View source","title":"#xml"},{"location":"azu/Azu/Response/Forbidden/","text":"class Azu::Response::Forbidden inherits Azu::Response::Error Methods #detail : String View source #status : HTTP :: Status View source #title : String View source","title":"Forbidden"},{"location":"azu/Azu/Response/Forbidden/#Azu::Response::Forbidden","text":"","title":"Forbidden"},{"location":"azu/Azu/Response/Forbidden/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Response/Forbidden/#Azu::Response::Forbidden#detail()","text":"View source","title":"#detail"},{"location":"azu/Azu/Response/Forbidden/#Azu::Response::Forbidden#status()","text":"View source","title":"#status"},{"location":"azu/Azu/Response/Forbidden/#Azu::Response::Forbidden#title()","text":"View source","title":"#title"},{"location":"azu/Azu/Response/NotFound/","text":"class Azu::Response::NotFound inherits Azu::Response::Error Class methods .new ( path : String ) View source Methods #render ( template : String , data ) View source","title":"NotFound"},{"location":"azu/Azu/Response/NotFound/#Azu::Response::NotFound","text":"","title":"NotFound"},{"location":"azu/Azu/Response/NotFound/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Response/NotFound/#Azu::Response::NotFound.new(path)","text":"View source","title":".new"},{"location":"azu/Azu/Response/NotFound/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Response/NotFound/#Azu::Response::NotFound#render(template,data)","text":"View source","title":"#render"},{"location":"azu/Azu/Router/Builder/","text":"class Azu::Router::Builder inherits Reference The Router::Builder class allows you to build routes more easily Class methods .new ( router : Router , scope : String = \"\" ) View source Macros method_missing ( call ) View source","title":"Builder"},{"location":"azu/Azu/Router/Builder/#Azu::Router::Builder","text":"The Router::Builder class allows you to build routes more easily","title":"Builder"},{"location":"azu/Azu/Router/Builder/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Router/Builder/#Azu::Router::Builder.new(router,scope)","text":"View source","title":".new"},{"location":"azu/Azu/Router/Builder/#macros","text":"","title":"Macros"},{"location":"azu/Azu/Router/Builder/#Azu::Router::Builder:method_missing(call)","text":"View source","title":"method_missing"},{"location":"azu/Azu/Router/DuplicateRoute/","text":"class Azu::Router::DuplicateRoute inherits Exception","title":"DuplicateRoute"},{"location":"azu/Azu/Router/DuplicateRoute/#Azu::Router::DuplicateRoute","text":"","title":"DuplicateRoute"},{"location":"azu/Azu/Router/Path/","text":"alias Azu::Router::Path Alias definition String","title":"Path"},{"location":"azu/Azu/Router/Path/#Azu::Router::Path","text":"","title":"Path"},{"location":"azu/Azu/Router/Path/#alias-definition","text":"String","title":"Alias definition"},{"location":"azu/Azu/Router/Route/","text":"struct Azu::Router::Route inherits Struct Class methods .new ( endpoint : HTTP :: Handler , resource : String , method : Method ) View source Methods #clone View source #copy_with ( endpoint _endpoint = @endpoint , resource _resource = @resource , method _method = @method ) View source #endpoint : HTTP :: Handler #method : Method #resource : String","title":"Route"},{"location":"azu/Azu/Router/Route/#Azu::Router::Route","text":"","title":"Route"},{"location":"azu/Azu/Router/Route/#class-methods","text":"","title":"Class methods"},{"location":"azu/Azu/Router/Route/#Azu::Router::Route.new(endpoint,resource,method)","text":"View source","title":".new"},{"location":"azu/Azu/Router/Route/#methods","text":"","title":"Methods"},{"location":"azu/Azu/Router/Route/#Azu::Router::Route#clone()","text":"View source","title":"#clone"},{"location":"azu/Azu/Router/Route/#Azu::Router::Route#copy_with(endpoint,resource,method)","text":"View source","title":"#copy_with"},{"location":"azu/Azu/Router/Route/#Azu::Router::Route#endpoint()","text":"","title":"#endpoint"},{"location":"azu/Azu/Router/Route/#Azu::Router::Route#method()","text":"","title":"#method"},{"location":"azu/Azu/Router/Route/#Azu::Router::Route#resource()","text":"","title":"#resource"},{"location":"azu/Azu/Templates/Renderable/","text":"module Azu::Templates::Renderable","title":"Renderable"},{"location":"azu/Azu/Templates/Renderable/#Azu::Templates::Renderable","text":"","title":"Renderable"}]}